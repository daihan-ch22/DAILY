코플릿 문제를 풀고 있는데 2시간 동안 끙끙 되었지만 결국 테스트 케이스를 전부 통과하지 못했다.

질문글을 올려놓긴 했는데 답변 달리면 다시 고쳐보자. 

## TOC
1. [문제](#문제)
2. [내가 푼 방식](# 내가-푼-방식)
3. [수정 전 코드](# 수정-전-코드)
4. [어떻게 해결했나?](#어떻게-해결했나?)
5. [수정 후 코드](# 수정-후-코드)


&nbsp;



## 문제
1. 배열로 짐들의 무게를 입력받고, int로 박스의 무게제한 을 받는다. 
2. 박스에는 최대 2개의 짐을 한번에 넣을 수 있다. (무게 제한을 넘지 않을때)       

&nbsp;


## 내가 푼 방식

[60, 73, 80, 87, 103, 109, 119, 123, 128, 129, 136, 146, 153, 168, 182], 200 이 주어졌을 때,

(60 + 73) (80 + 87) (103) (109) (119) (123) (128) (129) (136) (146) (153) (168) (182)

이렇게 총 13개의 박스가 필요할거라 생각했는데 답은 11이라고 나온다. 근본적인 부분부터 문제를 이해 못한것 같은데 그게 뭔지 모르겠다.

비공개 케이스도 전부 통과하지 못했다 ㅠ 결국 내 힘으로 풀지는 못했지만 그래도 디버그 하나하나 찍어가며 확인했던건 잘 했다고 생각함. 

&nbsp;&nbsp;

## 수정 전 코드

```
class Greedy1{
    public int movingStuff(int[] stuff, int limit)
    {
        int count = 0;
        int[] arr = stuff;
        int sum = 0;
        int maxCount = 0;
        Arrays.sort(arr, 0, stuff.length);

        for(int i =0; i<arr.length; i++) {

            if (arr[i] == limit) {  //아이템 하나의 무게가 박스 최대용량이면 박스개수+ 건너뛰기
                count++;
                continue;
            }

            if (arr[i] + sum <= limit) { //limit 보다 합한게 작으면
                sum += arr[i];
                maxCount ++;  //박스 2칸중 1칸 차지함
            } else if(arr[i] + sum > limit){
                count+=1;
                sum = arr[i];
                if(i == arr.length-1 && arr[i]==sum) count+=1; // 마지막 인덱스를 돌고있고 그게 sum값이면 (마지막남은것)
            }

            if(maxCount == 2){  // 박스가 2개까지만 넣을 수 있음
                count ++;
                sum = 0; // 다넣으면 박스 +1 / sum 초기화
                maxCount = 0;
            }

            /*if (sum >= limit) {
                count+=1; //1
                sum = 0;
            }*/
        }
        return count;
    }
}
```

## 어떻게 해결했나??
오늘 이 문제에 대해 크게 놓치고 있던것이 있었는데, greedy 알고리즘의 특징인 항상 그 순간순간에 최적의 결과를 찾아야 하는 것이었다. 

(60 + 73) (80 + 87) (103) (109) (119) (123) (128) (129) (136) (146) (153) (168) (182) 
이렇게 보면 13개의 박스를 써야하지만, 
(60 + 136) (73 + 123) (80 + 119) (87 + 109) (103) (128) (129) (146) (153) (168) (182)
이렇게하면 11개의 박스만 써도 된다. 


>즉 박스의 무게제한이 200이라 했을때 2개의 짐을 담는 동시에, 무게의 합이 200에 가장 근접해야 제일 효율적인 것이다.

>내가 했던 방식은 2개의 짐은 같이 담았지만 남는 무게가 컸기 때문에 효율적이지 않아서 그리디 알고리즘의 접근법이 아니었다. 

## 수정 후 코드
```
class Greedy1{
    public int movingStuff(int[] stuff, int limit) {
        int[] copiedArr = stuff;
        Arrays.sort(copiedArr);  //오름차순 정렬

        int sum = 0;                                // 짐 무게 더하는 변수
        int boxCount = 0;                            // 박스 개수 카운트
        int minVal = 0;                  // 시작 인덱스 (최소값)
        int maxVal = copiedArr.length - 1; // 끝 인덱스 (최대값)

        while (minVal < maxVal) //인덱스들이 배열의 중앙으로 이동할때까지
        {
            if (copiedArr[minVal] + copiedArr[maxVal] <= limit) //더해서 박스에 넣을 수 있을때
            {
                minVal++;   // 인덱스 +1 이동
                maxVal--;   // 인덱스 -1 이동
                boxCount++; // 박스 개수 1 증가
            } else { //무게 초과 시
                maxVal--;  //최소값 + 다음으로 가장 큰 최대값
                // 그러면 제일 큰 수면서 limit에 근접한 값을 얻을 수 있다.
            }
        }
        return copiedArr.length - boxCount;
        //copiedArr은 배열의 길이인데, 요소 1개당 박스 1개로 했을때의 경우의 수
        //boxCount로 2개씩 이동한 박스의 개수를 세었기 때문에
        // 총 경우의 수에서 이동한 박스의 경우의 수를 빼면 필요한 박스의 개수 나옴
    }
```
